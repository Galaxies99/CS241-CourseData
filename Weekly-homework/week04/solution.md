### week04 牛顿插值法

插值：给出 (n+1) 个点，要求找出一个 n 次多项式使得这个多项式经过这 (n+1) 个点。

**牛顿插值法**

牛顿的构想是：假如我只有一个点，那么我可以构造一个0次多项式函数f_0(x)，直接就可以满足条件了；如果我有两个点，在一个点的函数上修补一下得到一次多项式函数f_1(x)似乎也就可以满足条件了；以此类推……我就可以找到满足所有(n+1)个条件（(n+1)个点）的函数f_n(x) 啦~

引入**差商**的概念，定义：

0 阶差商 f[x_0] = f(x_0)

1 阶差商 f[x_0, x_1] = \frac{f[x_1] - f[x_0]}{x_1 - x_0}

2 阶差商 f[x_0, x_1, x_2] = \frac{f[x_1, x_2] - f[x_0, x_1]}{x_2 - x_0}

……

n 阶差商 f[x_0, x_1, ..., x_n] = \frac{f[x_1, x_2, ..., x_n] - f[x_0, x_1, ..., x_{n-1}]}{x_n - x_0}

我们考虑存在未知点 x 的差商形式，有：
$$
f[x] = f(x) \\
f[x, x_0] = \frac{f[x_0] - f[x]}{x_0-x} \Longrightarrow f[x] = f[x_0] + f[x, x_0](x - x_0) \\
f[x, x_0, x_1] = \frac{f[x_0, x_1] - f[x, x_0]}{x_1 - x} \Longrightarrow f[x, x_0] = f[x_0, x_1] + f[x, x_0, x_1] (x - x_1) \\
......
$$
我们关心的实际上是 f(x)，根据上式，也就是 f[x] 。

我们发现，这些式子之间存在着莫名的联系，我们把下一个式子代入上一个式子然后如此循环，最后就有
$$
f(x) = f[x] = f[x_0] + f[x_0,x_1](x-x_0) + f[x_0,x_1,x_2](x-x_0)(x-x_1) + ... \\
+ f[x_0,x_1,...,x_n](x-x_0)(x-x_1)...(x-x_{n-1}) \\
+ f[x, x_0,x_1,...,x_n](x-x_0)(x-x_1)...(x-x_n)
$$
这似乎是一个 (n+1) 次多项式，不过仔细一看我们可以发现，最后一项其实是个增量的形式，无论 x 取 x_0, x_1, ..., x_n 都为0，因此我们记
$$
R(x) = f[x, x_0,x_1,...,x_n](x-x_0)(x-x_1)...(x-x_n)
$$
为增量余项，所得多项式：
$$
f(x) = f[x_0] + f[x_0,x_1](x-x_0) + f[x_0,x_1,x_2](x-x_0)(x-x_1) + ... \\
+ f[x_0,x_1,...,x_n](x-x_0)(x-x_1)...(x-x_{n-1}) + R(x) \\
$$
取 R(x) = 0 即可得到经过这 (n+1) 个点的 n 次多项式 f_n(x) 啦~

至于求差商的话，列一张表 tab[i, j] = f[x_{j - i}, ... x_j]，则有
$$
tab[i, j] = \frac{tab[i-1, j] - tab[i-1, j-1]}{x_j - x_{j-i}}
$$
则可以递推啦，最后实际有用的其实只有 $tab[i, i]$。

时间复杂度 $O(n^2)$。

主要实现细节：

- 可能需要使用 printf 四舍五入并且利用奇怪操作来过精度问题。
- 有一个 error 是特殊字符比较难判断，要写 string parser（我的main.cpp里面前面非常丑陋的一段就是写的parser……）

本周题目主要难点：**字符串处理★★★**，**牛顿插值法★☆**





